## 需求：

### 1.存储用户的ID和Password

### 2.多次输入错误锁定

### 3.密码重置（忘记密码）-------->需要安全管理员的验证

### 4.S/Key验证（一次性口令系统）

### 5.强制密码更新（自定义个数以内不得重复使用相同的密码）

### 6.注册页面（要求密码复杂度不低于两种）

### 7.安全管理员及日志管理员

### 8.长时间未登录----------->冻结用户

### 

## 系统设计：

## 1.数据库（MySQL）（Server端）

### 	表一：服务器口令表（用于实现S/Key验证）

​			用户每注册或重置密码，都会查表三有无重复以及表四有无被锁定。

| 编号（外键） | 口令迭代值h | 挑战值N | 随机数R |
| :----------: | :---------: | :-----: | :-----: |
|      1       |             |         |         |
|      2       |             |         |         |
|      3       |             |         |         |

### 	表二：用户登录时间表（于登录时的时间进行差运算，算出登录间隔（t），实现长时间（T1）未登录冻结账户&规定时间（T2）必须重置密码的功能）

​			用户每登录一次，会将登录时间于表二中存的时间做差，将登录间隔t于T1和T2进行比较，实现不同的功能。

​			在用户退出时，会将退出时间存入表中，更新表中数据。

| 编号（外键） | 上次登录时间 |
| :----------: | :----------: |
|      1       |              |
|      2       |              |
|      3       |              |

### 	表三：用户历史密码表（设计密码次数n，实现n次以内不得重复使用相同密码）

​			用户注册或每n次更新密码，都会将密码的第N次迭代值存入表三中，备查。

| 编号（外键） | 历史密码的第N次迭代值1 | 历史密码的第N次迭代值2 | ...  | 历史密码的第N次迭代值n |
| :----------: | :--------------------: | :--------------------: | :--: | :--------------------: |
|      1       |                        |                        |      |                        |
|      2       |                        |                        |      |                        |
|      3       |                        |                        |      |                        |



### 	表四：用户账号锁定表（存储用户的ID和是否锁定）

​			提供用户锁定功能，配置文件里默认lock值为false。

​			true为被锁定，false反之。

| 编号（主键） |  ID  | lock（bool） |
| :----------: | :--: | :----------: |
|      1       |      |              |
|      2       |      |              |
|      3       |      |              |



## 2.C/S

### 	传输过程：

使用WebSocket进行传输，并使用信号量区分不同的功能。

### 	Client端（发送）

| 操作             | 信号量      | 作用                                         |
| ---------------- | ----------- | -------------------------------------------- |
| 注册             | C_enroll    | 通知服务端进行注册操作                       |
| 登录             | C_login     | 通知服务端进行登录操作                       |
| 重置密码（请求） | C_req_reset | 向服务端发送重置密码请求，等待安全管理员回应 |
| 重置密码（提交） | C_reset     | 通知服务端进行密码重置                       |
| 退出             | C_quit      | 通知服务端进行退出操作，同时发送ID           |
| 用户锁定         | C_lock      | 通知服务端进行用户锁定，同时发送用户ID       |
| 用户申请解除锁定 | C_unlock    | 向服务器申请解除锁定，同时发送用户ID         |



### 	Client端（接收）

| 信号量       | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| S_safe_reset | 客户端接收后提示密码需要重置，进入重置密码界面，重置理由（安全性） |
| S_login      | 客户端接收后提示登陆成功，进入系统主页                       |
| S_error      | 客户端接收后提示密码错误                                     |
| S_lock       | 客户端接收后返回登录界面                                     |
| S_unlock     | 客户端接收后提示用户，账户无法解冻                           |

​	

### 	Server端（发送）

| 操作         | 信号量       | 作用                                                         |
| ------------ | ------------ | ------------------------------------------------------------ |
| 密码需要重置 | S_safe_reset | 由于密码安全性等问题（登录时间间隔过长等）导致的需要重置密码时通知客户端，返回用户ID |
| 登录成功     | S_login      | ID，Password验证成功后，通知客户端                           |
| 密码错误     | S_error      | 进行迭代值比较时出错，通知客户端                             |
| 解冻成功     | S_lock       | 通知客户端，可以正常登录                                     |
| 解冻失败     | S_unlock     | 通知客户端，解冻失败                                         |



### 	Server端（接收）

| 信号量      | 作用                                           |
| ----------- | ---------------------------------------------- |
| C_enroll    | 进入注册阶段                                   |
| C_login     | 进入登录阶段                                   |
| C_req_reset | 在服务端的页面，向安全管理员提交申请，等待回应 |
| C_reset     | 进入密码重置流阶段                             |
| C_quit      | 将退出时间存入表三                             |
| C_lock      | 接收后处理表一，使bool值变为true               |
| C_unlock    | 接收后向安全管理员提交申请，等待回应           |



## 3.S/Key验证（一次性口令系统）

1. 客户端连接服务器，提示用户输入ID，将输入的ID发送到服务器
2. 服务器在表一中查询，根据ID是否存在，向客户端发送不同的反馈信息
3. 客户端收到反馈信息，根据内容判断：
   - ID不存在(进入注册阶段)，接受服务器发送的随机数R和挑战值N，随机数R和密码PW级联进行N次哈希运算得到h(N)，将结果h(N)和登录信号量发送给服务端，服务端将h(N)和n-1存表。
   - ID存在，且n == 2，则进入重置密码阶段，过程和用户名不存在的情况一样。
   - ID存在，且n > 2 ，接收服务器发送的随机数R和挑战值N，随机数R和密码PW级联进行N次哈希运算得到h(N)。将结果和登陆信号量发送给服务端，服务端再对h(N)进行一次哈希运算，于表中存的h(N+1)进行对比，若相同则返回登陆成功信号量，并更新表。若不同则返回密码错误。
4. 对于每一次登录，无论是否成功，都需要记录日志。
5. 重置密码阶段：服务器向客户端发送新的随机数R和挑战值N和重置密码信号量，随机数R和密码PW级联进行N次哈希运算得到h(N)，将结果h(N)和登录信号量发送给服务端，服务端将h(N)和n-1存表。



## 4.日志管理

​	日志文件：log.txt

​	日志格式（登录）：时间+用户ID+是否登录成功

​	日志格式（重置密码）：时间+用户ID+重置密码的第N次迭代值

​	日志格式（冻结）：时间+用户ID+账户被冻结\账户被解冻